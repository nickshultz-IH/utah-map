<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Southwest Utah Map — Intermountain Health</title>
  <meta name="description" content="Atlist-style map with Google Maps JS, Google Sheets, MarkerClusterer, and Intermountain styling." />
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@500;600;700&family=Source+Sans+3:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --sidebar-w: 380px;
      --accent: #4A00E2;   /* cluster/accents */
      --dark: #110057;     /* dark brand blue */
      --muted: #6b7280;
      --chip: #F7F5F9;
      --fade: 0.35;        /* faded opacity */
    }
    html, body { height: 100%; margin: 0; color: var(--dark); font-family: 'Source Sans 3', Arial, sans-serif; }
    h1, h2, h3, h4, .btn, .chip { font-family: 'Inter', Arial, sans-serif; }
    .app { height: 100vh; display: grid; grid-template-columns: var(--sidebar-w) 1fr; }
    .sidebar { height: 100%; overflow: hidden; border-right: 1px solid #e5e7eb; display: flex; flex-direction: column; background: #fff; }
    .sidebar header { padding: 16px 16px 8px; border-bottom: 1px solid #e5e7eb; }
    .sidebar h1 { margin: 0 0 6px; font-size: 20px; font-weight: 700; }
    .controls { padding: 12px 16px; border-bottom: 1px solid #e5e7eb; gap: 8px; display: grid; grid-template-columns: 1fr; background: #fff; }
    .row { display: flex; gap: 8px; align-items: center; }
    .row > * { flex: 1; }
    .search input { width:100%; padding: 10px 12px; border: 1px solid #d1d5db; border-radius: 10px; font-size: 14px; }
    .btn { appearance: none; border: 1px solid #d1d5db; background: #fff; border-radius: 10px; padding: 8px 10px; font-size: 13px; cursor: pointer; }
    .filters { padding: 10px 16px; overflow: auto; border-bottom: 1px solid #e5e7eb; max-height: 30%; background: #fff; }
    .filters h3 { margin: 10px 0 8px; font-size: 12px; color: var(--muted); text-transform: uppercase; letter-spacing: .06em; }
    .chips { display: flex; flex-wrap: wrap; gap: 6px; }
    .chip { display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; background: var(--chip); border: 1px solid #e5e7eb; border-radius: 999px; font-size: 12px; cursor: pointer; user-select: none; }
    .list { overflow: auto; flex: 1; background: #fff; }

    /* Group section (accordion) */
    .group-section { border-top: 1px solid #eee; }
    .group-head {
      display:flex; align-items:center; justify-content:space-between;
      padding: 10px 12px 10px 16px; font-size: 13px; color:#374151; font-weight:600;
      text-transform: uppercase; letter-spacing: .04em; background:#fafafa;
      position: sticky; top: 0; z-index: 1;
      border-bottom:1px solid #f0f0f0;
    }
    .group-head .title { display:flex; align-items:center; gap:10px; }
    .group-head .controls { display:flex; align-items:center; gap:10px; }
    .iconbtn { appearance:none; border:none; background:transparent; padding:4px; cursor:pointer; color:#374151; display:inline-flex; align-items:center; justify-content:center; border-radius:6px; }
    .iconbtn:hover { background:#efefef; }
    .chev { transition: transform .18s ease; }
    .collapsed .chev { transform: rotate(-90deg); }
    .faded { opacity: var(--fade); }

    .group-body { display:block; }
    .collapsed + .group-body { display:none; }

    .card { border-bottom: 1px solid #f3f4f6; padding: 12px 16px; cursor: pointer; display:flex; align-items:center; gap:10px; }
    .card:hover { background: #f9fafb; }
    .card h4 { margin: 0 0 2px; font-size: 15px; }
    .meta { color: var(--muted); font-size: 12px; }
    .pin-img { width: 20px; height: 20px; flex:0 0 20px; object-fit: contain; }
    #map { height: 100%; width: 100%; }

    /* InfoWindow content */
    .iw { max-width: 340px; font-family: 'Source Sans 3', Arial, sans-serif; }
    .iw .hero { position: relative; overflow: hidden; border-radius: 8px; }
    .iw .hero img { display:block; width:100%; height:auto; }
    .iw .tagpill { position:absolute; top:10px; left:10px; background:#ffffff; color:#111827; font-size:12px; padding:4px 10px; border-radius:999px; border:1px solid #e5e7eb; }
    .iw h3 { margin:10px 0 4px; font-size:18px; font-weight:700; }
    .iw .group { color:#374151; font-size:13px; margin-bottom:8px; }
    .iw .addr { color:#6b7280; font-size:12px; margin-bottom:8px; }
    .iw .btn-learn { display:block; width:100%; max-width:100%; box-sizing:border-box; text-align:center; padding:12px 14px; background:#110057; color:#fff; border-radius:10px; text-decoration:none; font-family:'Inter', Arial, sans-serif; font-weight:600; margin-top:10px; overflow:hidden; text-overflow:ellipsis; }
    .iw .body { display:none; } /* keywords hidden in bubble */

    @media (max-width: 768px) {
      .app { grid-template-columns: 1fr; grid-template-rows: auto 1fr; }
      .sidebar { grid-row: 1 / 2; border-right: 0; border-bottom: 1px solid #e5e7eb; }
      #map { grid-row: 2 / 3; height: 600px; }
    }
  </style>
</head>
<body>
  <div class="app">
    <aside class="sidebar">
      <header>
        <h1>Welcome to Southwest Utah</h1>
        <p>version 5</p>
        <div class="meta" id="summary">Loading places…</div>
      </header>
      <div class="controls">
        <div class="search">
          <input id="search" type="search" placeholder="Search by name, market or keywords" />
        </div>
        <div class="row">
          <button id="btn-nearme" class="btn" title="Sort list by distance">Use my location</button>
          <select id="sort" class="btn" aria-label="Sort">
            <option value="name">Sort: name (A→Z)</option>
            <option value="distance">Sort: nearest</option>
          </select>
          <button id="btn-reset" class="btn" title="Clear keywords & tag filters">Reset</button>
        </div>
      </div>
      <div class="filters">
        <h3>Markets</h3>
        <div id="tag-filters" class="chips"></div>
      </div>
      <div id="list" class="list"></div>
    </aside>
    <div id="map" role="application" aria-label="Map"></div>
  </div>

  <script>
    // ---- Config ----
    const CONFIG = {
      GOOGLE_MAPS_API_KEY: "AIzaSyAYvECoY90cl8YQwhKiBwEBKqW_zrK1AQY",
      SHEET: { id: "1cd3VUWQKs3zB68Ji-JXVjJkqyXi87KOoSErjypixD4I", range: "Sheet1!A:Z" },
      MAP: {
        center: { lat: 37.0953, lng: -113.5786 },
        zoom: 9,
        minZoom: 3,
        styles: [
          { "featureType": "administrative", "elementType": "all", "stylers": [ { "saturation": "-100" } ] },
          { "featureType": "administrative.province", "elementType": "all", "stylers": [ { "visibility": "off" } ] },
          { "featureType": "landscape", "elementType": "all", "stylers": [ { "saturation": -100 }, { "lightness": 65 }, { "visibility": "on" } ] },
          { "featureType": "poi", "elementType": "all", "stylers": [ { "saturation": -100 }, { "lightness": "50" }, { "visibility": "simplified" } ] },
          { "featureType": "road", "elementType": "all", "stylers": [ { "saturation": "-100" } ] },
          { "featureType": "road.highway", "elementType": "all", "stylers": [ { "visibility": "simplified" } ] },
          { "featureType": "road.arterial", "elementType": "all", "stylers": [ { "lightness": "30" } ] },
          { "featureType": "road.local", "elementType": "all", "stylers": [ { "lightness": "40" } ] },
          { "featureType": "transit", "elementType": "all", "stylers": [ { "saturation": -100 }, { "visibility": "simplified" } ] },
          { "featureType": "water", "elementType": "geometry", "stylers": [ { "hue": "#ffff00" }, { "lightness": -25 }, { "saturation": -97 } ] },
          { "featureType": "water", "elementType": "labels", "stylers": [ { "lightness": -25 }, { "saturation": -100 } ] }
        ]
      },
      UI: { cluster: true },
      ASSETS_BASE: "https://nickshultz-ih.github.io/utah-map/",
      ICON_TOKENS: {
        cobalt:"map-marker-cobalt.png",
        coral:"map-marker-coral.png",
        darkblue:"map-marker-darkblue.png",
        dark:"map-marker-darkblue.png",
        softblue:"map-marker-softblue.png",
        soft:"map-marker-softblue.png"
      },
      ICONS_BY_GROUP: {
        "Cobalt":"map-marker-cobalt.png",
        "Coral":"map-marker-coral.png",
        "Dark Blue":"map-marker-darkblue.png",
        "Soft Blue":"map-marker-softblue.png"
      }
    };

    let map, infoWindow, allPlaces = [], markers = [], clusterer = null;
    let userPos = null;

    // Per-group UI state: { [group]: { collapsed: boolean, faded: boolean } }
    const groupState = {};

    const $ = (sel) => document.querySelector(sel);
    const $$ = (sel) => Array.from(document.querySelectorAll(sel));

    // Icons (inline SVGs)
    const svgChevron = () => `
      <svg class="chev" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none"
           stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polyline points="6 9 12 15 18 9"></polyline>
      </svg>`;
    const svgEye = () => `
      <svg class="eye" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none"
           stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0"></path>
        <circle cx="12" cy="12" r="3"></circle>
      </svg>`;
    const svgEyeOff = () => `
      <svg class="eyeoff" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none"
           stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M10.733 5.076a10.744 10.744 0 0 1 11.205 6.575 1 1 0 0 1 0 .696 10.747 10.747 0 0 1-1.444 2.49"></path>
        <path d="M14.084 14.158a3 3 0 0 1-4.242-4.242"></path>
        <path d="M17.479 17.499a10.75 10.75 0 0 1-15.417-5.151 1 1 0 0 1 0-.696 10.75 10.75 0 0 1 4.446-5.143"></path>
        <path d="m2 2 20 20"></path>
      </svg>`;

    // Haversine (meters)
    function haversine(a, b) {
      const R = 6371e3;
      const toRad = (d) => d * Math.PI / 180;
      const dLat = toRad(b.lat - a.lat);
      const dLng = toRad(b.lng - a.lng);
      const lat1 = toRad(a.lat), lat2 = toRad(b.lat);
      const s = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLng/2)**2;
      return 2 * R * Math.asin(Math.sqrt(s));
    }

    function escapeHtml(str = "") {
      return str.replace(/[&<>"']/g, (c) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#039;" }[c]));
    }

    const uniq = (arr) => Array.from(new Set(arr.filter(Boolean))).sort((a,b)=>a.localeCompare(b));
    const parseList = (val) => val ? val.split(",").map(s=>s.trim()).filter(Boolean) : [];

    // Safe icon normalization (letters-only tokens or URL/filename)
    function normalizeIconValue(v) {
      if (!v) return "";
      const raw = String(v).trim();
      if (/^https?:\/\//i.test(raw)) return raw;                          // full URL
      if (/\.(png|jpe?g|svg|webp)$/i.test(raw))                           // filename in repo
        return CONFIG.ASSETS_BASE + raw.replace(/^\/+/, "");
      // Token: keep letters only -> "dark blue" -> "darkblue"
      const token = raw.toLowerCase().replace(/[^a-z]/g, "");
      const filename = CONFIG.ICON_TOKENS[token];
      return filename ? CONFIG.ASSETS_BASE + filename : "";
    }
    function resolveIconSrc(place) {
      const fromCell = normalizeIconValue(place.iconUrl);
      if (fromCell) return fromCell;
      const groupFile = CONFIG.ICONS_BY_GROUP[place.group];
      if (groupFile) return CONFIG.ASSETS_BASE + groupFile;
      return "";
    }
    function buildIcon(place) {
      const src = resolveIconSrc(place);
      return src ? { url: src, scaledSize: new google.maps.Size(36, 36) } : undefined;
    }

    // Bubble content — keywords intentionally hidden from UI
    function markerHtml(place) {
      const safeName = escapeHtml(place.name);
      const addr = place.address ? `<div class="addr">${escapeHtml(place.address)}</div>` : "";
      const group = place.group ? `<div class="group">${escapeHtml(place.group)}</div>` : "";
      const tag = (place.tags && place.tags[0]) ? `<div class="tagpill">${escapeHtml(place.tags[0])}</div>` : "";
      const headerImg = place.headerImage ? `<div class="hero"><img src="${place.headerImage}" alt="${safeName}"/>${tag}</div>` : "";
      const learnHref = place.moreUrl || ('https://www.google.com/search?q=' + encodeURIComponent(place.name + ' ' + (place.address||'')));
      return `
        <div class="iw">
          ${headerImg}
          <h3>${safeName}</h3>
          ${group}
          ${addr}
          <a class="btn-learn" href="${learnHref}" target="_blank" rel="noopener">Learn More</a>
        </div>`;
    }

    async function fetchSheetRows() {
      const url = `https://sheets.googleapis.com/v4/spreadsheets/${CONFIG.SHEET.id}/values/${encodeURIComponent(CONFIG.SHEET.range)}?key=${CONFIG.GOOGLE_MAPS_API_KEY}`;
      const res = await fetch(url);
      if (!res.ok) throw new Error(`Sheets API error ${res.status}`);
      const json = await res.json();
      const rows = json.values || [];
      if (!rows.length) return [];
      const headers = rows[0].map(h => (h || '').trim());
      return rows.slice(1).map(r => Object.fromEntries(headers.map((h,i) => [h, r[i] || ""])));
    }

    function normalizeRow(row) {
      const keywords = parseList(row["Keywords"] || row["Notes"] || "");  // keep for search only
      return {
        name: row["Name"] || "Untitled",
        address: row["Address"] || "",
        lat: parseFloat(row["Latitude"]) || null,
        lng: parseFloat(row["Longitude"]) || null,
        group: row["Group"] || "",
        tags: parseList(row["Tags"] || ""),
        iconUrl: row["Icon URL"] || "",
        headerImage: row["Header Image URL"] || "",
        moreUrl: row["Learn More URL"] || row["URL"] || "",
        useHtml: (row["Use HTML"] || "").toLowerCase() === 'true',
        keywordsText: keywords.join(", ")
      };
    }

    function groupBy(arr, keyFn) {
      const m = new Map();
      for (const it of arr) {
        const k = keyFn(it) || "Other";
        if (!m.has(k)) m.set(k, []);
        m.get(k).push(it);
      }
      return m;
    }

    // Open bubble anchored to marker (best UX when NOT clustered),
    // but also fall back to position to guarantee opening even if recently clustered.
    function openInfoForMarker(marker) {
      const p = marker.__data;
      infoWindow.setContent(markerHtml(p));
      try {
        infoWindow.open({ anchor: marker, map, shouldFocus: false });
      } catch (_) {
        infoWindow.open({ map, position: marker.getPosition(), shouldFocus: false });
      }
    }

    // Apply fade opacity to all markers in a group (without changing cluster icons)
    function applyGroupFadeToMarkers(groupName, faded) {
      const fadeVal = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--fade')) || 0.35;
      for (const mk of markers) {
        if (mk.__data.group === groupName && mk.getMap()) {
          mk.setOpacity(faded ? fadeVal : 1);
        }
      }
    }

    // Renders the grouped list with accordion & eye toggle
    function renderList(places) {
      const list = $("#list");
      list.innerHTML = "";
      const grouped = groupBy(places, p=>p.group);
      const groupsSorted = Array.from(grouped.keys()).sort((a,b)=>a.localeCompare(b));

      for (const g of groupsSorted) {
        if (!groupState[g]) groupState[g] = { collapsed: false, faded: false };

        const section = document.createElement("div");
        section.className = "group-section";

        // Header
        const head = document.createElement("div");
        head.className = "group-head" + (groupState[g].faded ? " faded" : "");
        head.dataset.group = g;

        const titleWrap = document.createElement("div");
        titleWrap.className = "title";
        const title = document.createElement("div");
        title.textContent = g || "Other";
        titleWrap.appendChild(title);

        const controls = document.createElement("div");
        controls.className = "controls";

        // Eye toggle button (fade group)
        const eyeBtn = document.createElement("button");
        eyeBtn.className = "iconbtn eye-toggle";
        eyeBtn.title = groupState[g].faded ? "Show group at full opacity" : "Fade this group";
        eyeBtn.innerHTML = groupState[g].faded ? svgEyeOff() : svgEye();
        eyeBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          groupState[g].faded = !groupState[g].faded;
          head.classList.toggle("faded", groupState[g].faded);
          eyeBtn.innerHTML = groupState[g].faded ? svgEyeOff() : svgEye();
          eyeBtn.title = groupState[g].faded ? "Show group at full opacity" : "Fade this group";
          applyGroupFadeToMarkers(g, groupState[g].faded);
          section.querySelectorAll(".card").forEach(el => el.classList.toggle("faded", groupState[g].faded));
        });

        // Chevron (accordion)
        const chevBtn = document.createElement("button");
        chevBtn.className = "iconbtn";
        chevBtn.innerHTML = `
          <svg class="chev" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none"
               stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="6 9 12 15 18 9"></polyline>
          </svg>`;

        controls.appendChild(eyeBtn);
        controls.appendChild(chevBtn);
        head.appendChild(titleWrap);
        head.appendChild(controls);
        section.appendChild(head);

        // Body
        const body = document.createElement("div");
        body.className = "group-body";
        if (groupState[g].collapsed) head.classList.add("collapsed");
        if (groupState[g].faded) body.classList.add("faded");

        // Toggle collapse on head click (ignore eye button)
        head.addEventListener("click", (e) => {
          if (e.target.closest(".eye-toggle")) return;
          groupState[g].collapsed = !groupState[g].collapsed;
          head.classList.toggle("collapsed", groupState[g].collapsed);
        });

        // Items
        for (const p of grouped.get(g)) {
          const item = document.createElement("div");
          item.className = "card";
          if (groupState[g].faded) item.classList.add("faded");

          const iconSrc = resolveIconSrc(p);
          const iconEl = iconSrc ? `<img class="pin-img" src="${iconSrc}" alt=""/>` : ``;
          item.innerHTML = `${iconEl}<div><h4>${escapeHtml(p.name)}</h4><div class="meta">${(p.tags||[]).join(' · ')}</div></div>`;

          // IMPORTANT: list-click guarantees the marker becomes visible and opens the bubble even if clustered/filtered
          item.addEventListener("click", () => {
            const m = markers.find(mk => mk.__data === p);
            if (!m) return;

            // If this item’s tags are currently unchecked, temporarily show it by checking those tags
            const neededTags = p.tags || [];
            if (neededTags.length) {
              const chips = $$("#tag-filters input[type=checkbox]");
              let changed = false;
              for (const chip of chips) {
                if (neededTags.includes(chip.value) && !chip.checked) { chip.checked = true; changed = true; }
              }
              if (changed) applyFilters();
            }

            // Ensure marker is on the map (might be filtered out)
            if (!m.getMap()) m.setMap(map);

            // Expand its group if collapsed
            groupState[g].collapsed = false;
            head.classList.remove("collapsed");

            // Pan/zoom to break cluster if needed, then open anchored bubble
            const pos = m.getPosition();
            map.panTo(pos);
            if (map.getZoom() < 13) map.setZoom(13);
            setTimeout(() => {
              openInfoForMarker(m);
            }, 120);
          });

          body.appendChild(item);
        }
        section.appendChild(body);
        list.appendChild(section);
      }

      // Summary
      $("#summary").textContent = `${places.length} place${places.length===1?'':'s'} shown`;
    }

    function buildFiltersUI() {
      const tags = uniq(allPlaces.flatMap(p=>p.tags||[]));
      const tagWrap = $("#tag-filters");
      tagWrap.innerHTML = tags
        .map(t=>`<label class="chip"><input type="checkbox" value="${escapeHtml(t)}" checked /> ${escapeHtml(t)}</label>`)
        .join('');
      tagWrap.addEventListener('change', applyFilters);
    }

    function refreshClusters() {
      if (!CONFIG.UI.cluster) return;
      if (!window.markerClusterer || !window.markerClusterer.MarkerClusterer) return;
      if (clusterer) clusterer.clearMarkers();
      const visible = markers.filter(m => m.getMap());
      if (visible.length) {
        const renderer = {
          render: ({ count, position }) => {
            const svg = window.btoa(`
              <svg xmlns='http://www.w3.org/2000/svg' width='44' height='44'>
                <circle cx='22' cy='22' r='20' fill='#4A00E2' />
                <text x='50%' y='52%' dominant-baseline='middle' text-anchor='middle' font-size='14' font-family='Inter, Arial' fill='white'>${count}</text>
              </svg>
            `);
            return new google.maps.Marker({
              position,
              icon: { url: 'data:image/svg+xml;base64,' + svg, scaledSize: new google.maps.Size(44,44) },
              zIndex: Number(google.maps.Marker.MAX_ZINDEX) + count,
            });
          }
        };
        clusterer = new window.markerClusterer.MarkerClusterer({ map, markers: visible, renderer });
      }
    }

    function applyFilters() {
      const q = $("#search").value.trim().toLowerCase();
      const activeTags = $$("#tag-filters input:checked").map(i=>i.value);

      const matches = [];
      for (const [idx, place] of allPlaces.entries()) {
        let ok = true;

        // Markets (tags) — inclusive logic; show when matches at least one checked tag. Show all when none defined.
        if (activeTags.length) {
          const ptags = place.tags || [];
          if (ptags.length && !ptags.some(tag => activeTags.includes(tag))) ok = false;
          // if place has no tags, keep it visible even when filters set
        }

        if (ok && q) {
          const hay = `${place.name} ${place.group} ${(place.tags||[]).join(' ')} ${place.keywordsText}`.toLowerCase();
          if (!hay.includes(q)) ok = false;
        }

        const marker = markers[idx];
        marker.setMap(ok ? map : null);

        // Maintain per-group fade on visible markers
        const st = groupState[place.group];
        if (ok && st && st.faded) {
          const fadeVal = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--fade')) || 0.35;
          marker.setOpacity(fadeVal);
        } else if (ok) {
          marker.setOpacity(1);
        }

        if (ok) matches.push(place);
      }

      // Sort
      if (userPos && $("#sort").value === 'distance') {
        for (const p of matches) p._distanceM = haversine(userPos, {lat: p.lat, lng: p.lng});
        matches.sort((a,b)=>a._distanceM-b._distanceM);
      } else {
        matches.sort((a,b)=>a.name.localeCompare(b.name));
      }

      renderList(matches);
      refreshClusters();

      // Re-apply list fades/collapses for groups currently faded/collapsed
      for (const section of $$(".group-section")) {
        const g = section.querySelector(".group-head")?.dataset.group || "";
        if (groupState[g]?.faded) {
          section.querySelector(".group-head")?.classList.add("faded");
          section.querySelectorAll(".card").forEach(el => el.classList.add("faded"));
        }
        if (groupState[g]?.collapsed) {
          section.querySelector(".group-head")?.classList.add("collapsed");
        }
      }
    }

    async function initApp() {
      try {
        const rows = await fetchSheetRows();
        allPlaces = rows.map(normalizeRow).filter(p => p.lat && p.lng);

        map = new google.maps.Map(document.getElementById('map'), {
          center: CONFIG.MAP.center,
          zoom: CONFIG.MAP.zoom,
          minZoom: CONFIG.MAP.minZoom,
          styles: CONFIG.MAP.styles,
          mapTypeControl: false,
          streetViewControl: false,
          fullscreenControl: true,
        });
        infoWindow = new google.maps.InfoWindow();

        markers = allPlaces.map((p) => {
          const marker = new google.maps.Marker({
            position: { lat: p.lat, lng: p.lng },
            map,
            title: p.name,
            icon: buildIcon(p),
          });
          marker.__data = p;

          // IMPORTANT: ensure marker click always opens bubble
          marker.addListener('click', () => openInfoForMarker(marker));
          return marker;
        });

        if (markers.length) {
          const bounds = new google.maps.LatLngBounds();
          markers.forEach(m => bounds.extend(m.getPosition()));
          map.fitBounds(bounds);
        }

        buildFiltersUI();
        $('#search').addEventListener('input', applyFilters);
        $('#sort').addEventListener('change', applyFilters);
        $('#btn-reset').addEventListener('click', () => {
          $$("#tag-filters input[type=checkbox]").forEach(i=>i.checked=true); // re-check all
          $('#search').value = '';
          $('#sort').value = 'name';
          // Reset fades & collapses
          Object.keys(groupState).forEach(k => groupState[k] = { collapsed:false, faded:false });
          applyFilters();
        });
        $('#btn-nearme').addEventListener('click', async () => {
          try {
            const pos = await getUserLocation();
            userPos = pos;
            new google.maps.Marker({ position: pos, map, title: 'You are here', icon: { path: google.maps.SymbolPath.CIRCLE, scale: 6, fillColor: '#4A00E2', fillOpacity: 1, strokeColor: '#fff', strokeWeight: 2 } });
            map.panTo(pos);
            $('#sort').value = 'distance';
            applyFilters();
          } catch (e) {
            alert('Location permission was denied or unavailable.');
          }
        });

        applyFilters();
      } catch (err) {
        console.error(err);
        alert('Failed to initialize: ' + err.message);
      }
    }

    function getUserLocation() {
      return new Promise((resolve, reject) => {
        if (!navigator.geolocation) return reject(new Error('No geolocation'));
        navigator.geolocation.getCurrentPosition(
          (pos) => resolve({ lat: pos.coords.latitude, lng: pos.coords.longitude }),
          (err) => reject(err),
          { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
        );
      });
    }

    // Load MarkerClusterer
    (function loadClusterer() {
      const s = document.createElement('script');
      s.src = "https://unpkg.com/@googlemaps/markerclusterer/dist/index.min.js";
      s.defer = true;
      s.addEventListener('load', () => { if (Array.isArray(markers) && markers.length) refreshClusters(); });
      document.head.appendChild(s);
    })();

    // Define callback before Maps loads
    window.__initMap = () => initApp();

    // Load Google Maps with the SAME key as Sheets (single source of truth)
    (function loadMaps() {
      const s = document.createElement('script');
      s.src = `https://maps.googleapis.com/maps/api/js?key=${CONFIG.AIzaSyAYvECoY90cl8YQwhKiBwEBKqW_zrK1AQY}&callback=__initMap`;
      s.async = true;
      document.head.appendChild(s);
    })();
  </script>
</body>
</html>
